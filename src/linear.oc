#include "linear.h"
#include "linear.oh"
#include "check_error.h"
#include "secure_multiplication/config.h"
#include "input.h"
#include "util.h"

int read_symmetric_linear_system_from_config(linear_system_t *ls, obliv fixed32_t *a, obliv fixed32_t *b) {
	// This function must only be executed by the parties that run the GC protocol: CSP and Evaluator,
	// with is'd 1 and 2 and c->party = 0 and 1, respectively.
	int num_data_providers = ls->num_data_providers;
	DualconR* conn = dcrConnect(ls->port, num_data_providers);
	size_t d = ls->a.d[0];

	obliv uint32_t *share_a;
	obliv uint32_t *share_b;
	for(int k = 0; k < num_data_providers; k++) {
	    // since A is symmetric, we only need to read half the matrix!
		for(size_t i = 0; i < d; i++) {
			for(size_t j = 0; j <= i; j++) {
				dcrRecvIntArray(conn, share_a, d*(d + 1)/2, k);
				a[idx(i,j)] += (obliv uint32_t) share_a[idx(i,j)];
			}
			dcrRecvIntArray(conn, share_b, d, k);
			b[i] = (obliv uint32_t) b[i] + share_b[i];
		}
	}
	dcrClose(conn);
	return 0;

error:
	return -1;
}

int read_symmetric_linear_system_from_ls(linear_system_t *ls, obliv fixed32_t *a, obliv fixed32_t *b) {
	// party 1 inputs matrix A and vector b, party 2 inputs the masks.
	obliv fixed32_t *mask_a, *mask_b;

	size_t d;
	// check inputs for validity
	bool valid_self = (ls && (d = ls->a.d[0]) == ls->a.d[1] && ls->b.len == d);
	bool valid_both = ocBroadcastBool(valid_self, 1) && ocBroadcastBool(valid_self, 2);
	check(valid_self, "Party %'s inputs are invalid.", ocCurrentParty());
	check(valid_both, "Party %'s inputs are invalid.", 3 - ocCurrentParty());

	// check if inputs have equal dimensions
	bool equal;
	revealOblivBool(&equal, 
		feedOblivInt(d, 1) ==
		feedOblivInt(d, 2), 0);
	check(equal, "Inputs of the two parties differ.");

	// since A is symmetric, we only need to read half the matrix!
	for(size_t i = 0; i < d; i++) {
		for(size_t j = 0; j <= i; j++) {
			obliv uint32_t mask = feedOblivInt(ls->a.value[i*d+j], 2);
			a[idx(i, j)] = feedOblivInt(ls->a.value[i*d+j], 1);

			a[idx(i,j)] = ((obliv uint32_t) a[idx(i,j)] + mask);
		}
		obliv uint32_t mask = feedOblivInt(ls->b.value[i], 2);
		b[i] = feedOblivInt(ls->b.value[i], 1);
		b[i] = (obliv uint32_t) b[i] + mask;
	}

	return 0;

error:
	return -1;
}

int read_symmetric_linear_system(linear_system_t *ls, obliv fixed32_t *a, obliv fixed32_t *b) {
	// This distinction is to maintain compatibility to our tests of phase 2 only
	if(!ls->port){
		return read_symmetric_linear_system_from_ls(ls, a, b);
	} else {
		return read_symmetric_linear_system_from_config(ls, a, b);
	}
}
