#include <obliv.oh>
#include "fixed.oh"

// returns a mask of the lowest (FIXED_BIT_SIZE + p) bits.
// saves garbled gates for some operations
//static int64_t fixed_mask(int p) {
//	return ((1ll << (FIXED_BIT_SIZE + p)) - 1);
//}

size_t ceildiv(size_t dividend, size_t divisor) {
	return (dividend + divisor - 1) / divisor;
}

void ofixed_add(obig *out, obig a, obig b) obliv {
	obig_add_signed(out, a, b);	
}

void ofixed_sub(obig *out, obig a, obig b) obliv {
	obig_sub_signed(out, a, b);	
}

void ofixed_mul(obig *out, obig a, obig b, size_t p) obliv {
	obig temp;
	~obliv() obig_init(&temp, a.digits + b.digits);
	obig_mul_signed(&temp, a, b);
	obig_shr_native_signed(out, temp, p);
	~obliv() obig_free(&temp);
}

obliv bool ofixed_div(obig *out, obig a, obig b, size_t p) obliv {
	obig temp;
	~obliv() obig_init(&temp, a.digits + ceildiv(p,8));
	obig_shl_native_signed(&temp, a, p);
	obliv bool result = obig_div_mod_signed(out, NULL, temp, b);
	~obliv() obig_free(&temp);
	return result;
}

void ofixed_sqrt(obig *out, obig a, size_t p) obliv {
	obig temp;
	~obliv() obig_init(&temp, a.digits + ceildiv(p,8));
	obig_shl_native_signed(&temp, a, p);
	obig_sqrt(out, temp);
	~obliv() obig_free(&temp);
}

