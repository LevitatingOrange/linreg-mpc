#include <obliv.oh>
#include "fixed.oh"

// returns a mask of the lowest (FIXED_BIT_SIZE + p) bits.
// saves garbled gates for some operations
//static int64_t fixed_mask(int p) {
//	return ((1ll << (FIXED_BIT_SIZE + p)) - 1);
//}

size_t ceildiv(size_t dividend, size_t divisor) {
	return (dividend + divisor - 1) / divisor;
}

void ofixed_max(obig *a) obliv {
	for(size_t i = 0; i < a->digits; i++) {
		if(i < a->digits - 1) {
			a->data[i] = (uint8_t) 0xFF;
		} else {
			a->data[i] = (uint8_t) 0x7F; // msb zero 
		}
	}
}

// checks if 'in' is greater than ofixed_max or less than -ofixed_max
// and sets 'out' to the respecitve limit if that's the case, and to 'in' 
// otherwise
void ofixed_check_overflow(obig *out, obig in) obliv {
//	obig_copy(out, in); 
//	return; // assume overflows don't happen
	if(in.digits <= out->digits) {
		obig_copy_signed(out, in); // definitely fits, just copy
		return;
	}
	obig temp, max;
	obig *tempptr = &temp;
	~obliv() obig_init(&temp, in.digits);
	~obliv() obig_init(&max, out->digits);
	ofixed_max(&max);
	obliv bool overflowed = false;
	obliv if(!obig_ltz_signed(in)) {
		obig_sub_signed(tempptr, in, max); // obig_cmp_signed is not yet implemented
		overflowed = (~obig_ltz_signed(temp)) & 1;
		obliv if(overflowed) {
			obig_copy_signed(out, max);
		}
	} else {
		obig_add_signed(tempptr, in, max);
		overflowed = obig_ltz_signed(temp);
		obliv if(overflowed) {
			obig_neg_signed(out, max); // min = -max
		}
	}
	obliv if(!overflowed) {
		obig_copy_signed(out, in);
	}
	~obliv() obig_free(&temp);
	~obliv() obig_free(&max);
}

void ofixed_add(obig *out, obig a, obig b) obliv {
	obig temp;
	~obliv() obig_init(&temp, (a.digits > b.digits ? a : b).digits + 1);
	obig_add_signed(&temp, a, b);	
	ofixed_check_overflow(out, temp);
	~obliv() obig_free(&temp);
}

void ofixed_sub(obig *out, obig a, obig b) obliv {
	obig temp;
	~obliv() obig_init(&temp, (a.digits > b.digits ? a : b).digits + 1);
	obig_sub_signed(&temp, a, b);	
	ofixed_check_overflow(out, temp);
	~obliv() obig_free(&temp);
}

void ofixed_mul(obig *out, obig a, obig b, size_t p) obliv {
	obig temp, temp2;
	~obliv() obig_init(&temp, a.digits + b.digits);
	~obliv() obig_init(&temp2, a.digits + b.digits);
	obig_mul_signed(&temp, a, b);
	obig_shr_native_signed(&temp2, temp, p);
	ofixed_check_overflow(out, temp2);
	~obliv() obig_free(&temp);
	~obliv() obig_free(&temp2);
}

obliv bool ofixed_div(obig *out, obig a, obig b, size_t p) obliv {
	obig temp, temp2, *tempptr = &temp, *temp2ptr = &temp2;
	obliv bool result;
	~obliv() obig_init(&temp, a.digits + ceildiv(p,8));
	~obliv() obig_init(&temp2, a.digits + ceildiv(p,8));
/*	obliv if(obig_eqz(b)) { // handle division by zero
		obliv bool a_neg = obig_ltz_signed(a);
		ofixed_max(out);
		obliv if(a_neg) {
			obig_neg(out, *out);
		}
	} else {*/
		obig_shl_native_signed(tempptr, a, p);
		result = obig_div_mod_signed(temp2ptr, NULL, temp, b);
		ofixed_check_overflow(out, temp2);
/*	}*/
	~obliv() obig_free(&temp);
	~obliv() obig_free(&temp2);
	return result;
}

void ofixed_sqrt(obig *out, obig a, size_t p) obliv {
	obig temp;
	~obliv() obig_init(&temp, a.digits + ceildiv(p,8));
	obig_shl_native_signed(&temp, a, p);
	obig_sqrt(out, temp);
	~obliv() obig_free(&temp);
}
