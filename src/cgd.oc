#include <obliv.oh>
#include <stdio.h>
#include <signal.h>
#include "linear.h"
#include "linear.oh"
#include "fixed.h"
#include "fixed.oh"
#include "util.h"


int flag = 0;
void sig_handler(int signo) {
	printf("Shutting down.\n");
	flag = 1;
}

// solves a symmetric, positive definite linear system using coordinate gradient descent
// and scaling.
void cgd(void *v) {
	double time_start = wallClock();

	struct sigaction act;
	act.sa_handler = &sig_handler;
	sigaction(SIGINT, &act, NULL);

	linear_system_t *ls = v;
	// allocate space for obliv values and read inputs
	// we can do most computations in-place in this case
	size_t d = ls->a.d[0];

	obig *a = malloc(((d * (d+1)) / 2) * sizeof(obig));
	for (size_t ii = 0; ii < ((d * (d+1)) / 2); ii++) {
		obig_init(&a[ii], FIXED_BIT_SIZE / 8);
	}
	obig *b = malloc(d * sizeof(obig));
	for (size_t ii = 0; ii < d; ii++) {
		obig_init(&b[ii], FIXED_BIT_SIZE / 8);
	}
	
	if(read_symmetric_linear_system(ls, a, b)) {
		fprintf(stderr, "Could not read inputs.");
		ls->beta.len = -1;
		free(a);
		free(b);
		return;
	}
	// allocate output vector if not already done and we are party 2
	if(!(ls->beta.value) && ocCurrentParty() == 2) {
		ls->beta.len = d;
		ls->beta.value = malloc(d * sizeof(fixed64_t));
	}
	
	obig *x = malloc(d * sizeof(obig));
	obig *ax = malloc(d * sizeof(obig));
	obig *p = malloc(d * sizeof(obig));
	obig *gammap = malloc(d * sizeof(obig));
	obig *g = malloc(d * sizeof(obig));
	obig *pscl = malloc(d * sizeof(obig));
	obig *pA = malloc(d * sizeof(obig));
	obig *etapscl = malloc(d * sizeof(obig));
	obig *gdq = malloc(d * sizeof(obig));
	obig *etap = malloc(d * sizeof(obig));
	obig *gdeta = malloc(d * sizeof(obig));
	obig *result = malloc(d * sizeof(obig));
	for (size_t ii = 0; ii < d; ii++) {
		obig_init(&x[ii], FIXED_BIT_SIZE / 8);
		obig_init(&ax[ii], FIXED_BIT_SIZE / 8);
		obig_init(&p[ii], FIXED_BIT_SIZE / 8);
		obig_init(&gammap[ii], FIXED_BIT_SIZE / 8);
		obig_init(&g[ii], FIXED_BIT_SIZE / 8);
		obig_init(&pscl[ii], FIXED_BIT_SIZE / 8);
		obig_init(&pA[ii], FIXED_BIT_SIZE / 8);
		obig_init(&etapscl[ii], FIXED_BIT_SIZE / 8);
		obig_init(&gdq[ii], FIXED_BIT_SIZE / 8);
		obig_init(&etap[ii], FIXED_BIT_SIZE / 8);
		obig_init(&gdeta[ii], FIXED_BIT_SIZE / 8);
		obig_init(&result[ii], FIXED_BIT_SIZE / 8);
	}

	// loop for a fixed number of iterations
	fixed64_t temp;
	obliv fixed64_t otemp;
	obig obigtemp;
	obig_init(&obigtemp, FIXED_BIT_SIZE / 8);
	obig ng;
	obig_init(&ng, FIXED_BIT_SIZE / 8);
	obig q;
	obig_init(&q, FIXED_BIT_SIZE / 8);
	obig eta;
	obig_init(&eta, FIXED_BIT_SIZE / 8);
	obig gamma;
	obig_init(&gamma, FIXED_BIT_SIZE / 8);
	obig d_big;
	obig_init(&d_big, FIXED_BIT_SIZE / 8);

	int prec = ls->precision;

	// initialise
	// Ax(:) = A*x;
	// p(:) = Ax - b;
	// g(:) = p;
	for(size_t i = 0; i < d; i++) {
		ofixed_sub(&g[i], g[i], b[i]);
		obig_copy_signed(&p[i], g[i]);
		obig_import_onative(&d_big, d);
	}

	// ng(:) = g'*g;
	for(size_t i = 0; i < d; i++) {
		ofixed_mul(&obigtemp, g[i], g[i], prec);
		ofixed_add(&ng, ng, obigtemp);
	}

	if(ocCurrentParty() == 2) {printf("OT time: %f\nStarting iterations.\n", wallClock() - time_start);}
	//double time = wallClock();
	obliv bool q_nonzero = true;
	for(size_t t = 0; !flag && t < ls->num_iterations; t++) {	
		// pscl(:) = p;
		for(size_t i = 0; i < d; i++) {
			obig_mul_signed(&pscl[i], p[i], d_big);
			//obig_copy_signed(&pscl[i], p[i]);
		}
		
		// pA(:) = p'*A;
		for(size_t i = 0; i < d; i++) {
			obig_zero(&pA[i]);
			for(size_t j = 0; j < d; j++) {
				ofixed_mul(&obigtemp, a[idx(i,j)], p[j], prec);
				ofixed_add(&pA[i], pA[i], obigtemp);
			}
		}
		
		// q(:) = pA*pscl;
		obig_zero(&q);
		ofixed_inner_product(&q, pA, pscl, prec, d);
		// for(size_t i = 0; i < d; i++) {
		// 	ofixed_mul(&obigtemp, pA[i], pscl[i], prec);
		// 	ofixed_add(&q, q, obigtemp);
		// }
		obliv if(q_nonzero) {
			q_nonzero = (~obig_eqz(q)) & 1;
			obliv if(!q_nonzero) {
				for(size_t i = 0; i < d; i++) {
					obig_copy(&result[i], x[i]);
				}
			}
		}
		
		// not allowed to create new pointers in obliv if block
		obig *eta_ptr = &eta;
		obig *obigtemp_ptr = &obigtemp;
		obig *gamma_ptr = &gamma;
		obig *ng_ptr = &ng;
		obig *eta_ptr = &eta;
		
//		obliv if(q_nonzero) {
			// // eta(:) = ng/q;
			// eta = q/ng; 
			// we use the inverse here so it's < 1
			// the obliv if switch below ensures there are no updates after
			// eta becomes zero
			ofixed_div(eta_ptr, q, ng, prec);

			// // etapscl(:) = eta*pscl;
			// etapscl(:) = pscl / eta;
			// x(:) = x - etapscl;
			for(size_t i = 0; i < d; i++) {
				ofixed_div(&etapscl[i], pscl[i], eta, prec);
				ofixed_sub(&x[i], x[i], etapscl[i]);
			}

			// Ax(:) = A*x;
			// g(:) = Ax - b;
			for(size_t i = 0; i < d; i++) {
				obig_zero(&ax[i]);
				for(size_t j = 0; j < d; j++) {
					size_t ij = idx(i, j);
					ofixed_mul(obigtemp_ptr, a[ij], x[j], prec);
					ofixed_add(&ax[i], ax[i], obigtemp);
				}
				ofixed_sub(&g[i], ax[i], b[i]);
			}
			
			// // gdeta(:) = g/eta;
			// gdeta(:) = g * eta;
			// gdq(:) = g/q;
			// gamma(:) = gdeta'*gdq;
			obig_zero(gamma_ptr);
			for(size_t i = 0; i < d; i++) {
				ofixed_mul(&gdeta[i], g[i], eta, prec);
				ofixed_div_overflow(&gdq[i], g[i], q, prec);
				ofixed_mul(obigtemp_ptr, gdeta[i], gdq[i], prec);
				ofixed_add(gamma_ptr, gamma, obigtemp);
			}
			
	    // gammap(:) = gamma*p;
			// p(:) = g + gammap;
			for(size_t i = 0; i < d; i++) {
				ofixed_mul(&gammap[i], gamma, p[i], prec);
				ofixed_add(&p[i], g[i], gammap[i]);
			}
			
			// ng(:) = g'*g;
			obig_zero(ng_ptr);
			for(size_t i = 0; i < d; i++) {
				ofixed_mul(obigtemp_ptr, g[i], g[i], prec);
				ofixed_add(ng_ptr, ng, obigtemp);
			}
//		}

		if(ocCurrentParty() == 2) printf("Iteration %d:\n", t);
		for(size_t i = 0; i < d; i++) {
			bool q_nonzero_revealed;
			revealOblivBool(&q_nonzero_revealed, q_nonzero, 0);
			otemp = obig_export_onative_signed( // print the correct value
				q_nonzero_revealed ? x[i] : result[i]);
			revealOblivLLong(&temp, otemp, 2);
			//p[i] = g[i] + ofixed_mul(gamma, p[i], prec);
			//revealOblivInt(&temp, beta[i], 2);
			if(ocCurrentParty() == 2) printf("%20.15f ", fixed_to_double(temp, prec));
		}
		otemp = obig_export_onative_signed(gamma);
		revealOblivLLong(&temp, otemp, 2);
		if(ocCurrentParty() == 2) printf("\nGamma: %30.20f ", fixed_to_double(temp, prec));
		otemp = obig_export_onative_signed(eta);
		revealOblivLLong(&temp, otemp, 2);
		if(ocCurrentParty() == 2) printf("\nEta: %30.20f ", fixed_to_double(temp, prec));
		otemp = obig_export_onative_signed(q);
		revealOblivLLong(&temp, otemp, 2);
		if(ocCurrentParty() == 2) printf("\nq: %30.20f ", fixed_to_double(temp, prec));
		otemp = obig_export_onative_signed(ng);
		revealOblivLLong(&temp, otemp, 2);
		if(ocCurrentParty() == 2) printf("\nng: %30.20f ", fixed_to_double(temp, prec));
		if(ocCurrentParty() == 2) {
			if(!ocInDebugProto())  {
				printf("\nIteration %d gate count: %lld", t, yaoGateCount());
			}
			printf("\nIteration %d time: %f\n", t, wallClock() - time_start);
		}

		flag = ocBroadcastBool(flag, 1) || ocBroadcastBool(flag, 2);
	}
	
	obliv if(q_nonzero) {
		for(size_t i = 0; i < d; i++) {
			obig_copy(&result[i], x[i]);
		}
	}
	
	// return the result
	for(size_t i = 0; i < d; i++) {
		otemp = obig_export_onative_signed(result[i]);
		revealOblivLLong(ls->beta.value + i, otemp, 2); // <- is this right, or should it be &ls->beta.value[i]? <- isn't that the same?
		//revealOblivInt(ls->beta.value + i, beta[i], 2);
	}
	if(!ocInDebugProto()) {
		ls->gates = yaoGateCount();
	}
	obig_free(&ng);
	obig_free(&q);
	obig_free(&eta);
	obig_free(&gamma);
	for (size_t ii = 0; ii < ((d * (d+1)) / 2); ii++) {
		obig_free(&a[ii]);
	}
	for (size_t ii = 0; ii < d; ii++) {
		obig_free(&b[ii]);
		obig_free(&x[ii]);
		obig_free(&ax[ii]);
		obig_free(&p[ii]);
		obig_free(&gammap[ii]);
		obig_free(&g[ii]);
		obig_free(&pscl[ii]);
		obig_free(&pA[ii]);
		obig_free(&etapscl[ii]);
		obig_free(&gdq[ii]);
		obig_free(&etap[ii]);
		obig_free(&gdeta[ii]);
	}
	free(a);
	free(b);
	free(x);
	free(ax);
	free(p);
	free(gammap);
	free(g);
	free(pscl);
	free(pA);
	free(etapscl);
	free(gdq);
	free(etap);
	free(gdeta);
	return;
}
