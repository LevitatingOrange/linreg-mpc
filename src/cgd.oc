#include <obliv.oh>
#include <stdio.h>
#include "linear.h"
#include "linear.oh"
#include "fixed.h"
#include "fixed.oh"
#include <signal.h>
//#include "util.h"


int flag = 0;
void sig_handler(int signo) {
	printf("Shutting down.\n");
	flag = 1;
}

// solves a symmetric, positive definite linear system using coordinate gradient descent
// and scaling.
void cgd(void *v) {

	struct sigaction act;
	act.sa_handler = &sig_handler;
	sigaction(SIGINT, &act, NULL);

	linear_system_t *ls = v;
	// allocate space for obliv values and read inputs
	// we can do most computations in-place in this case
	size_t d = ls->a.d[0];
	
	obig *a = malloc(((d * (d+1)) / 2) * sizeof(obig));
	for (size_t ii = 0; ii < ((d * (d+1)) / 2); ii++) {
		obig_init(&a[ii], FIXED_BIT_SIZE / 8);
	}

	obig *b = malloc(d * sizeof(obig));
	obig *g = malloc(d * sizeof(obig));
	obig *p = malloc(d * sizeof(obig));
	obig *p_tilde = malloc(d * sizeof(obig));
	obig *ap_tilde = malloc(d * sizeof(obig));
	obig *beta = malloc(d * sizeof(obig));
	obig *abeta = malloc(d * sizeof(obig));
	obig *m = malloc(d * sizeof(obig));
	for (size_t ii = 0; ii < d; ii++) {
		obig_init(&b[ii], FIXED_BIT_SIZE / 8);
		obig_init(&g[ii], FIXED_BIT_SIZE / 8);
		obig_init(&p[ii], FIXED_BIT_SIZE / 8);
		obig_init(&p_tilde[ii], FIXED_BIT_SIZE / 8);
		obig_init(&ap_tilde[ii], FIXED_BIT_SIZE / 8);
		obig_init(&beta[ii], FIXED_BIT_SIZE / 8);
		obig_init(&abeta[ii], FIXED_BIT_SIZE / 8);
		obig_init(&m[ii], FIXED_BIT_SIZE / 8);
	}

	if(read_symmetric_linear_system(ls, a, b)) {
		fprintf(stderr, "Could not read inputs.");
		ls->beta.len = -1;
		free(a);
		free(b);
		return;
	}

	// allocate output vector if not already done and we are party 2
	if(!(ls->beta.value) && ocCurrentParty() == 2) {
		ls->beta.len = d;
		ls->beta.value = malloc(d * sizeof(fixed64_t));
	}

	// loop for a fixed number of iterations
	fixed64_t temp;
	obliv fixed64_t otemp;
	obig obigtemp;
	obig_init(&obigtemp, FIXED_BIT_SIZE / 8);
	obig obigtemp2;
	obig_init(&obigtemp2, FIXED_BIT_SIZE / 8);
	obig eta;
	obig_init(&eta, FIXED_BIT_SIZE / 8);
	obig gamma;
	obig_init(&gamma, FIXED_BIT_SIZE / 8);
	obig q;
	obig_init(&q, FIXED_BIT_SIZE / 8);
	
	int prec = ls->precision;
/*	if(ocCurrentParty() == 2) printf("m = ");
	for(size_t i = 0; i < d; i++) {
		// scaling diagonal matrix
		obig_zero(&m[i]);
		//m[i] = 0;
		for(size_t j = 0; j < d; j++) {
			//obliv fixed32_t a_ij = a[idx(i,j)];
			//obliv if(a_ij > 0) {
			//	m[i] += a_ij;
			size_t idxij = idx(i,j);
			obliv if(obig_gtz_signed(a[idxij])) {
				ofixed_add(&m[i], m[i], a[idxij]);
			} else {
				ofixed_sub(&m[i], m[i], a[idxij]);
				//m[i] -= a_ij;
			}
		}
		ofixed_sqrt(&m[i], m[i], prec);
		otemp = obig_export_onative_signed(m[i]);
		revealOblivLLong(&temp, otemp, 2);
		//m[i] = ofixed_sqrt(m[i], prec);
		//revealOblivInt(&temp, m[i], 2);
		if(ocCurrentParty() == 2) printf("%20.15f ", fixed_to_double(temp, prec));
	}
	if(ocCurrentParty() == 2) printf("\n");

	// scale A and b
	for(size_t i = 0; i < d; i++) {
		for(size_t j = 0; j <= i; j++) { // A is symmetric
			ofixed_div(&a[idx(i,j)], a[idx(i,j)], m[i], prec);
			ofixed_div(&a[idx(i,j)], a[idx(i,j)], m[j], prec);
			//a[idx(i,j)] = ofixed_div(a[idx(i,j)], m[i], prec);
			//a[idx(i,j)] = ofixed_div(a[idx(i,j)], m[j], prec);
		}
		ofixed_div(&b[i], b[i], m[i], prec);
		//b[i] = ofixed_div(b[i], m[i], prec);
	}
*/

	// initialise
	for(size_t i = 0; i < d; i++) {
		ofixed_sub(&g[i], g[i], b[i]);
		obig_copy_signed(&p[i], g[i]);
		//beta[i] = 0;
		//g[i] = b[i];
		//p[i] = g[i];
	}

	obig n, n_old;
	obig_init(&n, FIXED_BIT_SIZE / 8);
	obig_init(&n_old, FIXED_BIT_SIZE/8);
	for(size_t i = 0; i < d; i++) {
		ofixed_mul(&obigtemp, g[i], g[i], prec);
		ofixed_add(&n, n, obigtemp);
	}

	if(ocCurrentParty() == 2) {printf("Starting iterations.\n");}
	//double time = wallClock();
	for(size_t t = 0; !flag && t < ls->num_iterations; t++) {
		obig_zero(&eta);
		obig_zero(&gamma);
		obig_zero(&q);
		//obliv fixed32_t eta = 0, gamma = 0, q = 0;
		for(size_t i = 0; i < d; i++) {
			obig_import_onative(&obigtemp, double_to_fixed(d, prec));
			ofixed_mul(&p_tilde[i], p[i], obigtemp, prec);
		}
		for(size_t i = 0; i < d; i++) {
			obig_zero(&ap_tilde[i]);
			for(size_t j = 0; j < d; j++) {
				ofixed_mul(&obigtemp, a[idx(i,j)], p_tilde[j], prec);
				ofixed_add(&ap_tilde[i], ap_tilde[i], obigtemp);
				//ap[i] += ofixed_mul(a[idx(i,j)], p[j], prec);
			}
			ofixed_mul(&obigtemp, p[i], ap_tilde[i], prec);
			ofixed_add(&q, q, obigtemp);
			//q += ofixed_mul(p[i], ap[i], prec);
		}

		ofixed_div(&eta, n, q, prec);

		for(size_t i = 0; i < d; i++) {
			ofixed_mul(&obigtemp, eta, p_tilde[i], prec);
			ofixed_sub(&beta[i], beta[i], obigtemp);
			//beta[i] += ofixed_mul(eta, p[i], prec);
		}

		obig_copy_signed(&n_old, n);
		obig_zero(&n);
		for(size_t i = 0; i < d; i++) {
			obig_zero(&abeta[i]);
			for(size_t j = 0; j < d; j++) {
				ofixed_mul(&obigtemp, a[idx(i,j)], beta[j], prec);
				ofixed_add(&abeta[i], abeta[i], obigtemp);
			}
			ofixed_sub(&g[i], abeta[i], b[i]);
			ofixed_mul(&obigtemp, g[i], g[i], prec);
			ofixed_add(&n, obigtemp, n);
		}
		ofixed_div(&gamma, n, n_old, prec);
		
		if(ocCurrentParty() == 2) printf("Iteration %d:\n", t);
		for(size_t i = 0; i < d; i++) {
			ofixed_mul(&obigtemp, gamma, p[i], prec);
			ofixed_add(&p[i], obigtemp, g[i]);
			otemp = obig_export_onative_signed(beta[i]);
			revealOblivLLong(&temp, otemp, 2);
			//p[i] = g[i] + ofixed_mul(gamma, p[i], prec);
			//revealOblivInt(&temp, beta[i], 2);
			if(ocCurrentParty() == 2) printf("%20.15f ", fixed_to_double(temp, prec));
		}
		if(ocCurrentParty() == 2) printf("\n");
		if(ocCurrentParty() == 2) printf("Yao's gates count: %lld", yaoGateCount());
		if(ocCurrentParty() == 2) printf("\n");

		flag = ocBroadcastBool(flag, 1) || ocBroadcastBool(flag, 2);
	}
/*
	// re-scale beta
	for(size_t i = 0; i < d; i++) {
		ofixed_div(&beta[i], beta[i], m[i], prec);
		//beta[i] = ofixed_div(beta[i], m[i], prec);
	}
*/
	// return the result
	for(size_t i = 0; i < d; i++) {
		otemp = obig_export_onative_signed(beta[i]);
		revealOblivLLong(ls->beta.value + i, otemp, 2); // <- is this right, or should it be &ls->beta.value[i]? <- isn't that the same?
		//revealOblivInt(ls->beta.value + i, beta[i], 2);
	}

	ls->gates = yaoGateCount();
	obig_free(&obigtemp);
	obig_free(&obigtemp2);
	obig_free(&eta);
	obig_free(&gamma);
	obig_free(&q);
	obig_free(&n);
	obig_free(&n_old);
	for (size_t ii = 0; ii < ((d * (d+1)) / 2); ii++) {
		obig_free(&a[ii]);
	}
	for (size_t ii = 0; ii < d; ii++) {
		obig_free(&b[ii]);
		obig_free(&g[ii]);
		obig_free(&p[ii]);
		obig_free(&p_tilde[ii]);
		obig_free(&ap_tilde[ii]);
		obig_free(&beta[ii]);
		obig_free(&abeta[ii]);
		obig_free(&m[ii]);
	}
	free(a);
	free(b);
	free(g);
	free(p);
	free(p_tilde);
	free(ap_tilde);
	free(beta);
	free(abeta);
	free(m);
	return;

}
