#include <obliv.oh>
#include <stdio.h>
#include <signal.h>
#include "linear.h"
#include "linear.oh"
#include "fixed.h"
#include "fixed.oh"
#include "util.h"


int flag = 0;
void sig_handler(int signo) {
	printf("Shutting down.\n");
	flag = 1;
}

// solves a symmetric, positive definite linear system using coordinate gradient descent
// and scaling.
void cgd(void *v) {
	double time_start = wallClock();

	struct sigaction act;
	act.sa_handler = &sig_handler;
	sigaction(SIGINT, &act, NULL);

	linear_system_t *ls = v;
	// allocate space for obliv values and read inputs
	// we can do most computations in-place in this case
	size_t d = ls->a.d[0];

	obig *a = malloc(((d * (d+1)) / 2) * sizeof(obig));
	for (size_t ii = 0; ii < ((d * (d+1)) / 2); ii++) {
		obig_init(&a[ii], FIXED_BIT_SIZE / 8);
	}
	obig *b = malloc(d * sizeof(obig));
	for (size_t ii = 0; ii < d; ii++) {
		obig_init(&b[ii], FIXED_BIT_SIZE / 8);
	}
	
	if(read_symmetric_linear_system(ls, a, b)) {
		fprintf(stderr, "Could not read inputs.");
		ls->beta.len = -1;
		free(a);
		free(b);
		return;
	}
	// allocate output vector if not already done and we are party 2
	if(!(ls->beta.value) && ocCurrentParty() == 2) {
		ls->beta.len = d;
		ls->beta.value = malloc(d * sizeof(uint64_t));
	}
	
	obig *x = malloc(d * sizeof(obig));
	obig *ax = malloc(d * sizeof(obig));
	obig *p = malloc(d * sizeof(obig));
	obig *g = malloc(d * sizeof(obig));
	obig *gscl = malloc(d * sizeof(obig));
	obig *pA = malloc(d * sizeof(obig));
	obig *result = malloc(d * sizeof(obig));
	for (size_t ii = 0; ii < d; ii++) {
		obig_init(&x[ii], FIXED_BIT_SIZE / 8);
		obig_init(&ax[ii], FIXED_BIT_SIZE / 8);
		obig_init(&p[ii], FIXED_BIT_SIZE / 8);
		obig_init(&g[ii], FIXED_BIT_SIZE / 8);
		obig_init(&gscl[ii], FIXED_BIT_SIZE / 8);
		obig_init(&pA[ii], FIXED_BIT_SIZE / 8);
		obig_init(&result[ii], FIXED_BIT_SIZE / 8);
	}

	// loop for a fixed number of iterations
	fixed64_t temp;
	obliv fixed64_t otemp;
	obig obigtemp;
	obig_init(&obigtemp, FIXED_BIT_SIZE / 8);
	obig ng;
	obig_init(&ng, FIXED_BIT_SIZE / 8);
	obig *ng_ptr = &ng;
	obig q;
	obig_init(&q, FIXED_BIT_SIZE / 8);
	obig eta;
	obig_init(&eta, FIXED_BIT_SIZE / 8);
	obig gamma;
	obig_init(&gamma, FIXED_BIT_SIZE / 8);
	obig gAp;
	obig_init(&gAp, FIXED_BIT_SIZE / 8);
	obig gp;
	obig_init(&gp, FIXED_BIT_SIZE / 8);

	int prec = ls->precision;

	// initialise
	// Ax(:) = A*x;
	// g(:) = Ax - b;
	// ng = inf_norm(g)
	// gscl = g/ng
	// p = gscl
	for(size_t i = 0; i < d; i++) {
		ofixed_sub(&g[i], g[i], b[i]);
		obig_abs(&obigtemp, g[i]);
		obliv if(obig_gt(obigtemp, ng)){
			obig_copy_signed(ng_ptr, obigtemp);
		}
	}

	for(size_t i = 0; i < d; i++) {
		ofixed_div(&p[i], g[i], ng, prec);
	}

	if(ocCurrentParty() == 2) {printf("OT time: %f\nStarting iterations.\n", wallClock() - time_start);}
	//double time = wallClock();
	obliv bool q_nonzero = true;
	for(size_t t = 0; !flag && t < ls->num_iterations; t++) {	
		/*// pscl(:) = p;
		for(size_t i = 0; i < d; i++) {
			obig_mul_signed(&pscl[i], p[i], d_big);
			//obig_copy_signed(&pscl[i], p[i]);
		}
		*/
		// pA(:) = p'*A;
		for(size_t i = 0; i < d; i++) {
			obig_zero(&pA[i]);
			for(size_t j = 0; j < d; j++) {
				ofixed_mul(&obigtemp, a[idx(i,j)], p[j], prec);
				ofixed_add(&pA[i], pA[i], obigtemp);
			}
		}
		
		// q(:) = pA*p;
		ofixed_inner_product(&q, pA, p, prec, d);
		// gp(:) = g'*p;
		ofixed_inner_product(&gp, g, p, prec, d);
		
		// eta(:) = mydivide(TT,gp,q);
		ofixed_div(&eta, gp, q, prec);

		// etap(:) = eta*p;
		// x(:) = x - etap;
		// etaAp(:) = eta*(pA)';
		// g(:) = g - etaAp;
		// ng(:) = max(abs(g));
		obig_zero(ng_ptr);
		for(size_t i = 0; i < d; i++) {
			ofixed_mul(&obigtemp, p[i], eta, prec);
			ofixed_sub(&x[i], x[i], obigtemp);
			ofixed_mul(&obigtemp, eta, pA[i], prec);
			ofixed_sub(&g[i], g[i], obigtemp);
			obig_abs(&obigtemp, g[i]);
			obliv if(obig_gt(obigtemp, ng)){
				obig_copy_signed(ng_ptr, obigtemp);
			}
		}

		// gscl(:) = mydivide(TT,g,ng);
		for(size_t i = 0; i < d; i++) {
			ofixed_div(&gscl[i], g[i], ng, prec);
		}
		// gAp(:) = pA*gscl;
		ofixed_inner_product(&gAp, pA, gscl, prec, d);
		// gamma(:) = mydivide(TT,gAp,q);
		ofixed_div(&gamma, gAp, q, prec);
		// gammap(:) = gamma*p;
		// p(:) = gscl - gammap;
		for(size_t i = 0; i < d; i++) {
			ofixed_mul(&obigtemp, p[i], gamma, prec);
			ofixed_sub(&p[i], gscl[i], obigtemp);
		}

		if(ocCurrentParty() == 2) printf("Iteration %d (x):\n", t);
		for(size_t i = 0; i < d; i++) {
			bool q_nonzero_revealed;
			revealOblivBool(&q_nonzero_revealed, q_nonzero, 0);
			otemp = obig_export_onative_signed( // print the correct value
				q_nonzero_revealed ? x[i] : result[i]);
			revealOblivLLong(&temp, otemp, 2);
			//p[i] = g[i] + ofixed_mul(gamma, p[i], prec);
			//revealOblivInt(&temp, beta[i], 2);
			if(ocCurrentParty() == 2) printf("%20.15f ", fixed_to_double(temp, prec));
		}
		/*if(ocCurrentParty() == 2) printf("\nIteration %d (g):\n", t);
		for(size_t i = 0; i < d; i++) {
			otemp = obig_export_onative_signed(g[i]);
			revealOblivLLong(&temp, otemp, 2);
			if(ocCurrentParty() == 2) printf("%20.15f ", fixed_to_double(temp, prec));
		}*/
		otemp = obig_export_onative_signed(gamma);
		revealOblivLLong(&temp, otemp, 2);
		if(ocCurrentParty() == 2) printf("\nGamma: %30.20f ", fixed_to_double(temp, prec));
		otemp = obig_export_onative_signed(eta);
		revealOblivLLong(&temp, otemp, 2);
		if(ocCurrentParty() == 2) printf("\nEta: %30.20f ", fixed_to_double(temp, prec));
		otemp = obig_export_onative_signed(q);
		revealOblivLLong(&temp, otemp, 2);
		if(ocCurrentParty() == 2) printf("\nq: %30.20f ", fixed_to_double(temp, prec));
		otemp = obig_export_onative_signed(ng);
		revealOblivLLong(&temp, otemp, 2);
		if(ocCurrentParty() == 2) printf("\nng: %30.20f ", fixed_to_double(temp, prec));
		if(ocCurrentParty() == 2) {
			if(!ocInDebugProto())  {
				printf("\nIteration %d gate count: %lld", t, yaoGateCount());
			}
			printf("\nIteration %d time: %f\n", t, wallClock() - time_start);
		}

		flag = ocBroadcastBool(flag, 1) || ocBroadcastBool(flag, 2);
	}
	
	
	for(size_t i = 0; i < d; i++) {
			obig_copy(&result[i], x[i]);
	}
	
	// return the result
	for(size_t i = 0; i < d; i++) {
		otemp = obig_export_onative_signed(result[i]);
		revealOblivLLong(ls->beta.value + i, otemp, 2); // <- is this right, or should it be &ls->beta.value[i]? <- isn't that the same?
		//revealOblivInt(ls->beta.value + i, beta[i], 2);
	}
	if(!ocInDebugProto()) {
		ls->gates = yaoGateCount();
	}
	obig_free(&ng);
	obig_free(&q);
	obig_free(&eta);
	obig_free(&gamma);
	obig_free(&obigtemp);
	obig_free(&gAp);
	obig_free(&gp);

	for (size_t ii = 0; ii < ((d * (d+1)) / 2); ii++) {
		obig_free(&a[ii]);
	}
	for (size_t ii = 0; ii < d; ii++) {
		obig_free(&b[ii]);
		obig_free(&x[ii]);
		obig_free(&ax[ii]);
		obig_free(&p[ii]);
		obig_free(&g[ii]);
		obig_free(&gscl[ii]);
		obig_free(&pA[ii]);
	}
	free(a);
    free(b);
    free(x);
    free(ax);
    free(p);
    free(g);
    free(gscl);
    free(pA);
	return;
}
