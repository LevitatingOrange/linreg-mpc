#include <obliv.oh>
#include <stdio.h>
#include "linear.h"
#include "linear.oh"
#include "fixed.h"
#include "fixed.oh"
#include <signal.h>
//#include "util.h"

int flag = 0;
void sig_handler(int signo) {
	printf("Shutting down.\n");
	flag = 1;
}

// solves a symmetric, positive definite linear system using coordinate gradient descent
// and scaling.
void cgd(void *v) {

	struct sigaction act;
	act.sa_handler = &sig_handler;
	sigaction(SIGINT, &act, NULL);

	linear_system_t *ls = v;
	// allocate space for obliv values and read inputs
	// we can do most computations in-place in this case
	size_t d = ls->a.d[0];
	
	obig *a = alloca(((d * (d+1)) / 2) * sizeof(obig));
	for (size_t ii = 0; ii < ((d * (d+1)) / 2); ii++) {
		obig_init(&a[ii], FIXED_BIT_SIZE/8+(ls->precision/8));
	}

	obig *b = alloca(d * sizeof(obig));
	obig *g = alloca(d * sizeof(obig));
	obig *p = alloca(d * sizeof(obig));
	obig *beta = alloca(d * sizeof(obig));
	obig *ap = alloca(d * sizeof(obig));
	obig *m = alloca(d * sizeof(obig));
	for (size_t ii = 0; ii < d; ii++) {
		obig_init(&b[ii], FIXED_BIT_SIZE/8+(ls->precision/8));
		obig_init(&g[ii], FIXED_BIT_SIZE/8+(ls->precision/8));
		obig_init(&p[ii], FIXED_BIT_SIZE/8+(ls->precision/8));
		obig_init(&beta[ii], FIXED_BIT_SIZE/8+(ls->precision/8));
		obig_init(&ap[ii], FIXED_BIT_SIZE/8+(ls->precision/8));
		obig_init(&m[ii], FIXED_BIT_SIZE/8+(ls->precision/8));
	}

	if(read_symmetric_linear_system(ls, a, b)) {
		fprintf(stderr, "Could not read inputs.");
		ls->beta.len = -1;
		return;
	}

	// allocate output vector if not already done and we are party 2
	if(!(ls->beta.value) && ocCurrentParty() == 2) {
		ls->beta.len = d;
		ls->beta.value = malloc(d * sizeof(fixed32_t));
	}

	// loop for a fixed number of iterations
	fixed32_t temp;
	obliv fixed32_t otemp;
	obig obigtemp;
	obig_init(&obigtemp, FIXED_BIT_SIZE/8+(ls->precision/8));
	obig obigtemp2;
	obig_init(&obigtemp2, FIXED_BIT_SIZE/8+(ls->precision/8));
	obig eta;
	obig_init(&eta, FIXED_BIT_SIZE/8+(ls->precision/8));
	obig gamma;
	obig_init(&gamma, FIXED_BIT_SIZE/8+(ls->precision/8));
	obig q;
	obig_init(&q, FIXED_BIT_SIZE/8+(ls->precision/8));
	
	int prec = ls->precision;
	if(ocCurrentParty() == 2) printf("m = ");
	for(size_t i = 0; i < d; i++) {
		// scaling diagonal matrix
		obig_zero(&m[i]);
		//m[i] = 0;
		for(size_t j = 0; j < d; j++) {
			//obliv fixed32_t a_ij = a[idx(i,j)];
			//obliv if(a_ij > 0) {
			//	m[i] += a_ij;
			size_t idxij = idx(i,j);
			obliv if(obig_gtz_signed(a[idxij])) {
				ofixed_add(&m[i], m[i], a[idxij]);
			} else {
				ofixed_sub(&m[i], m[i], a[idxij]);
				//m[i] -= a_ij;
			}
		}
		ofixed_sqrt(&m[i], m[i], prec);
		otemp = obig_export_onative_signed(m[i]);
		revealOblivInt(&temp, otemp, 2);
		//m[i] = ofixed_sqrt(m[i], prec);
		//revealOblivInt(&temp, m[i], 2);
		if(ocCurrentParty() == 2) printf("%20.15f ", fixed_to_double(temp, prec));
	}
	if(ocCurrentParty() == 2) printf("\n");

	// scale A and b
	for(size_t i = 0; i < d; i++) {
		for(size_t j = 0; j <= i; j++) { // A is symmetric
			ofixed_div(&a[idx(i,j)], a[idx(i,j)], m[i], prec);
			ofixed_div(&a[idx(i,j)], a[idx(i,j)], m[j], prec);
			//a[idx(i,j)] = ofixed_div(a[idx(i,j)], m[i], prec);
			//a[idx(i,j)] = ofixed_div(a[idx(i,j)], m[j], prec);
		}
		ofixed_div(&b[i], b[i], m[i], prec);
		//b[i] = ofixed_div(b[i], m[i], prec);
	}


	// initialise
	for(size_t i = 0; i < d; i++) {
		obig_zero(&beta[i]);
		obig_copy_signed(&g[i], b[i]);
		obig_copy_signed(&p[i], g[i]);
		//beta[i] = 0;
		//g[i] = b[i];
		//p[i] = g[i];
	}

	if(ocCurrentParty() == 2) {printf("Starting iterations.\n");}
	//double time = wallClock();
	for(size_t t = 0; !flag && t < ls->num_iterations; t++) {
		obig_zero(&eta);
		obig_zero(&gamma);
		obig_zero(&q);
		//obliv fixed32_t eta = 0, gamma = 0, q = 0;
		for(size_t i = 0; i < d; i++) {
			obig_zero(&ap[i]);
			//ap[i] = 0;
			for(size_t j = 0; j < d; j++) {
				ofixed_mul(&obigtemp, a[idx(i,j)], p[j], prec);
				ofixed_add(&ap[i], ap[i], obigtemp);
				//ap[i] += ofixed_mul(a[idx(i,j)], p[j], prec);
			}
			ofixed_mul(&obigtemp, p[i], ap[i], prec);
			ofixed_add(&q, q, obigtemp);
			//q += ofixed_mul(p[i], ap[i], prec);
		}

		for(size_t i = 0; i < d; i++) {
			ofixed_div(&obigtemp, g[i], q, prec);
			ofixed_mul(&obigtemp, obigtemp, g[i], prec);
			ofixed_add(&eta, eta, obigtemp);
			//eta += ofixed_mul(ofixed_div(g[i], q, prec), g[i], prec);
		}

		for(size_t i = 0; i < d; i++) {
			ofixed_mul(&obigtemp, eta, p[i], prec);
			ofixed_add(&beta[i], beta[i], obigtemp);
			//beta[i] += ofixed_mul(eta, p[i], prec);
		}

		for(size_t i = 0; i < d; i++) {
			ofixed_mul(&obigtemp, eta, ap[i], prec);
			ofixed_sub(&g[i], g[i], obigtemp);
			ofixed_div(&obigtemp, g[i], eta, prec);
			ofixed_div(&obigtemp2, g[i], q, prec);
			ofixed_mul(&obigtemp, obigtemp, obigtemp2, prec);
			ofixed_add(&gamma, gamma, obigtemp);
			//g[i] -= ofixed_mul(eta, ap[i], prec);
			//gamma += ofixed_mul(ofixed_div(g[i], eta, prec), ofixed_div(g[i], q, prec), prec);
		}
		
		if(ocCurrentParty() == 2) printf("Iteration %d:\n", t);
		for(size_t i = 0; i < d; i++) {
			ofixed_mul(&obigtemp, gamma, p[i], prec);
			ofixed_add(&p[i], obigtemp, g[i]);
			otemp = obig_export_onative_signed(beta[i]);
			revealOblivInt(&temp, otemp, 2);
			//p[i] = g[i] + ofixed_mul(gamma, p[i], prec);
			//revealOblivInt(&temp, beta[i], 2);
			if(ocCurrentParty() == 2) printf("%20.15f ", fixed_to_double(temp, prec));
		}
		if(ocCurrentParty() == 2) printf("\n");
		if(ocCurrentParty() == 2) printf("Yao's gates count: %d", yaoGateCount());
		if(ocCurrentParty() == 2) printf("\n");

		flag = ocBroadcastBool(flag, 1) || ocBroadcastBool(flag, 2);
	}

	// re-scale beta
	for(size_t i = 0; i < d; i++) {
		ofixed_div(&beta[i], beta[i], m[i], prec);
		//beta[i] = ofixed_div(beta[i], m[i], prec);
	}

	// return the result
	for(size_t i = 0; i < d; i++) {
		otemp = obig_export_onative_signed(beta[i]);
		revealOblivInt(ls->beta.value + i, otemp, 2); // <- is this right, or should it be &ls->beta.value[i]?
		//revealOblivInt(ls->beta.value + i, beta[i], 2);
	}

	ls->gates = yaoGateCount();

	obig_free(&obigtemp);
	obig_free(&obigtemp2);
	obig_free(&eta);
	obig_free(&gamma);
	obig_free(&q);
	for (size_t ii = 0; ii < ((d * (d+1)) / 2); ii++) {
		obig_free(&a[ii]);
	}
	for (size_t ii = 0; ii < d; ii++) {
		obig_free(&b[ii]);
		obig_free(&g[ii]);
		obig_free(&p[ii]);
		obig_free(&beta[ii]);
		obig_free(&ap[ii]);
		obig_free(&m[ii]);
	}
	return;

}
